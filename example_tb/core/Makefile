# Copyright 2019 Clifford Wolf
# Copyright 2019 Robert Balas
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
# AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
# INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
# LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
# OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
# PERFORMANCE OF THIS SOFTWARE.

# Author: Robert Balas (balasr@iis.ee.ethz.ch)
#
# Description: Makefile for running the following examples:
#
#              - 'Hello World' (custom), command line 'make custom-vsim-run'
#              - 'Floating Point example' (custom_fp), command line 'make custom-fp-vsim-run'
#              - 'Interrupt example' (interrupt), command line 'make interrupt-vsim-run'

MAKE			= make

# vsim configuration
VVERSION                = "10.7b"

VLIB			= vlib-$(VVERSION)
VWORK			= work

VLOG			= vlog-$(VVERSION)
VLOG_FLAGS		= -pedanticerrors -suppress 2577 -suppress 2583 -define CV32E40P_TRACE_EXECUTION
VLOG_LOG                = vloggy

VOPT			= vopt-$(VVERSION)
VOPT_FLAGS		= -debugdb -fsmdebug -pedanticerrors +acc #=mnprft

VSIM			= vsim-$(VVERSION)
VSIM_HOME               = /usr/pack/modelsim-$(VVERSION)-kgf/questasim
VSIM_FLAGS              =  # user defined
ALL_VSIM_FLAGS		= $(VSIM_FLAGS)
VSIM_DEBUG_FLAGS	= -debugdb
VSIM_GUI_FLAGS          = -gui -debugdb
VSIM_SCRIPT             = vsim.tcl

# rivierapro configuration
ALIB                    = "vlib"
AWORK                   = work

ALOG                    = vlog
ALOG_FLAGS              = # user defined
ALL_ALOG_FLAGS          = $(ALOG_FLAGS) +define+CV32E40P_TRACE_EXECUTION 

ASIM                    = vsim
ASIM_HOME               = $$ALDEC_PATH/bin
ASIM_FLAGS              = # user defined
ALL_ASIM_FLAGS          = $(ASIM_FLAGS)
ASIM_DEBUG_FLAGS        =
ASIM_GUI_FLAGS          = -gui

# RTL source files
RTLSRC_HOME             := ../..
RTLSRC_TB_PKG		:= include/perturbation_pkg.sv
RTLSRC_TB_TOP		:= tb_top.sv
RTLSRC_TB		:= $(wildcard *.sv)
RTLSRC_INCDIR           := $(RTLSRC_HOME)/rtl/include
RTLSRC_BHV_PKG		:= $(RTLSRC_HOME)/bhv/include/cv32e40p_tracer_pkg.sv
RTLSRC_BHV		:= $(filter-out $(RTLSRC_HOME)/bhv/cv32e40p_tracer.sv $(RTLSRC_HOME)/bhv/cv32e40p_core_log.sv $(RTLSRC_HOME)/bhv/cv32e40p_apu_tracer.sv, $(wildcard $(RTLSRC_HOME)/bhv/*.sv))
RTLSRC_BHV_INCDIR	:= $(RTLSRC_HOME)/bhv/include
RTLSRC_PKG		:= $(RTLSRC_HOME)/rtl/fpnew/src/fpnew_pkg.sv \
				$(addprefix $(RTLSRC_HOME)/rtl/include/,\
				cv32e40p_apu_core_pkg.sv cv32e40p_pkg.sv)
RTLSRC			:= $(filter-out $(RTLSRC_HOME)/rtl/cv32e40p_register_file_latch.sv,\
				$(wildcard $(RTLSRC_HOME)/rtl/*.sv))
RTLSRC_FPNEW_INCDIR := $(RTLSRC_HOME)/rtl/fpnew/src/common_cells/include
RTLSRC_FPNEWPKG     := $(RTLSRC_HOME)/rtl/fpnew/src/fpu_div_sqrt_mvp/hdl/defs_div_sqrt_mvp.sv
RTLSRC_FPNEW        := $(wildcard $(RTLSRC_HOME)/rtl/fpnew/src/*.sv) $(wildcard $(RTLSRC_HOME)/rtl/fpnew/src/fpu_div_sqrt_mvp/hdl/*.sv) \
                    $(wildcard $(RTLSRC_HOME)/rtl/fpnew/src/common_cells/src/*.sv) $(wildcard $(RTLSRC_HOME)/rtl/fpnew/src/common_cells/src/deprecated/*.sv)

RTLSRC_VLOG_TB_TOP	:= $(basename $(notdir $(RTLSRC_TB_TOP)))
RTLSRC_VOPT_TB_TOP	:= $(addsuffix _vopt, $(RTLSRC_VLOG_TB_TOP))

# riscv toolchain install path
RISCV                    ?= ~/.riscv
RISCV_EXE_PREFIX         = $(RISCV)/bin/riscv32-unknown-elf-

# assume vsim if no target chosen
.DEFAULT_GOAL := custom-vsim-run

# GCC configuration
CUSTOM_GCC_FLAGS           =

all: custom-vsim-run

#riviera testbench compilation
alib: .rvrlib-rtl

.rvrlib-rtl: 
	$(ALIB) $(AWORK)
	touch .rvrlib-rtl

#rebuild if we change some sourcefile
.rvr-build-rtl: .rvrlib-rtl $(RTLSRC_PKG) $(RTLSRC) $(RTLSRC_BHV_PKG) $(RTLSRC_BHV) $(RTLSRC_TB_PKG) $(RTLSRC_TB)
	$(ALOG) -work $(AWORK) +incdir+$(RTLSRC_INCDIR) +incdir+$(RTLSRC_BHV_INCDIR) $(ALL_ALOG_FLAGS) \
	$(RTLSRC_PKG) $(RTLSRC) $(RTLSRC_BHV_PKG) $(RTLSRC_BHV) $(RTLSRC_TB_PKG) $(RTLSRC_TB)
	touch .rvr-build-rtl

asim-all: .rvr-build-rtl

# rebuild if we change some sourcefile
.rvr-build-rtl-fp: .rvrlib-rtl $(RTLSRC_PKG) $(RTLSRC_FPNEWPKG) $(RTLSRC_FPNEW) $(RTLSRC) $(RTLSRC_BHV_PKG) $(RTLSRC_BHV) $(RTLSRC_TB_PKG) $(RTLSRC_TB)
	$(ALOG) -work $(AWORK) +incdir+$(RTLSRC_INCDIR) +incdir+$(RTLSRC_BHV_INCDIR) +incdir+$(RTLSRC_FPNEW_INCDIR) $(ALL_ALOG_FLAGS) \
	$(RTLSRC_PKG) $(RTLSRC_FPNEWPKG) $(RTLSRC_FPNEW) $(RTLSRC) $(RTLSRC_BHV_PKG) $(RTLSRC_BHV) $(RTLSRC_TB_PKG) $(RTLSRC_TB)
	touch .rvr-build-rtl-fp

asim-all-fp: .rvr-build-rtl-fp

#run tb and exit
.PHONY: asim-run
asim-run: ALL_ASIM_FLAGS += -c
asim-run: 
	$(ASIM) -lib $(AWORK) $(RTLSRC_VLOG_TB_TOP) $(ALL_ASIM_FLAGS) \
	-do "run -all; endsim; quit -force"

#run rb and drop into interactive shell
.PHONY: asim-run-sh
asim-run-sh: ALL_ASIM_FLAGS += -c
asim-run-sh: 
	$(ASIM) -lib $(AWORK) $(RTLSRC_VLOG_TB_TOP) $(ALL_ASIM_FLAGS) \
	-do "run -all; endsim"

# run tb with simulator gui
.PHONY: asim-run-gui
asim-run-gui: ALL_ASIM_FLAGS += $(ASIM_GUI_FLAGS)
asim-run-gui:
	$(ASIM) -lib $(AWORK) $(RTLSRC_VLOG_TB_TOP) $(ALL_ASIM_FLAGS) \
	-do "run -all; endsim"

.PHONY: rvr-tb-clean
rvr-tb-clean:
	if [ -d $(AWORK) ]; then rm -r $(AWORK); fi
	rm -f transcript asim.wlf asim.dbg trace_core*.log \
	.asim-rtl .rvr-build-rtl .rvr-asim-rtl .alib-rtl *.vcd objdump dpi_header.h \
	library.cfg dataset.asdb

# run tb and exit
.PHONY: asim-run-fp
asim-run-fp: ALL_ASIM_FLAGS += -c
asim-run-fp: asim-all-fp
	$(ASIM) -lib $(AWORK) $(RTLSRC_VLOG_TB_TOP) $(ALL_ASIM_FLAGS) -gFPU=1 \
	-do "run -all; endsim; quit -force"

# run tb and drop into interactive shell
.PHONY: asim-run-sh-fp
asim-run-sh-fp: ALL_ASIM_FLAGS += -c
asim-run-sh-fp: asim-all-fp
	$(ASIM) -lib $(AWORK) $(RTLSRC_VLOG_TB_TOP) $(ALL_ASIM_FLAGS) -gFPU=1 \
	-do "run -all; endsim"

# run tb with simulator gui
.PHONY: asim-run-gui-fp
asim-run-gui-fp: ALL_ASIM_FLAGS += $(ASIM_GUI_FLAGS)
asim-run-gui-fp: asim-all-fp
	$(ASIM) -lib $(AWORK) $(RTLSRC_VLOG_TB_TOP) $(ALL_ASIM_FLAGS) -gFPU=1 \
	-do "run -all; endsim"

.PHONY: rvr-tb-clean-fp
rvr-tb-clean-fp:
	if [ -d $(AWORK) ]; then rm -r $(AWORK); fi
	rm -f transcript asim.wlf asim.dbg trace_core*.log \
	.rvr-build-rtl-fp .rvr-asim-rtl-fp .alib-rtl-fp *.vcd objdump

# vsim testbench compilation and optimization
vlib: .lib-rtl

.lib-rtl:
	$(VLIB) $(VWORK)
	touch .lib-rtl

# rebuild if we change some sourcefile
.build-rtl: .lib-rtl $(RTLSRC_PKG) $(RTLSRC) $(RTLSRC_BHV_PKG) $(RTLSRC_BHV) $(RTLSRC_TB_PKG) $(RTLSRC_TB)
	$(VLOG) -work $(VWORK) +incdir+$(RTLSRC_INCDIR) +incdir+$(RTLSRC_BHV_INCDIR) $(VLOG_FLAGS) \
	$(RTLSRC_PKG) $(RTLSRC) $(RTLSRC_BHV_PKG) $(RTLSRC_BHV) $(RTLSRC_TB_PKG) $(RTLSRC_TB)
	touch .build-rtl

vsim-all: .opt-rtl

.opt-rtl: .build-rtl
	$(VOPT) -work $(VWORK) $(VOPT_FLAGS) $(RTLSRC_VLOG_TB_TOP) -o \
	$(RTLSRC_VOPT_TB_TOP)
	touch .opt-rtl

# rebuild if we change some sourcefile
.build-rtl-fp: .lib-rtl $(RTLSRC_PKG) $(RTLSRC_FPNEWPKG) $(RTLSRC_FPNEW) $(RTLSRC) $(RTLSRC_BHV_PKG) $(RTLSRC_BHV) $(RTLSRC_TB_PKG) $(RTLSRC_TB)
	$(VLOG) -work $(VWORK) +incdir+$(RTLSRC_INCDIR) +incdir+$(RTLSRC_BHV_INCDIR) +incdir+$(RTLSRC_FPNEW_INCDIR) $(VLOG_FLAGS) \
	$(RTLSRC_PKG) $(RTLSRC_FPNEWPKG) $(RTLSRC_FPNEW) $(RTLSRC) $(RTLSRC_BHV_PKG) $(RTLSRC_BHV) $(RTLSRC_TB_PKG) $(RTLSRC_TB)
	touch .build-rtl-fp

vsim-all-fp: .opt-rtl-fp

.opt-rtl-fp: .build-rtl-fp
	$(VOPT) -work $(VWORK) $(VOPT_FLAGS) -g FPU=1 $(RTLSRC_VLOG_TB_TOP) -o \
	$(RTLSRC_VOPT_TB_TOP)
	touch .opt-rtl-fp

# run tb and exit
.PHONY: vsim-run
vsim-run: ALL_VSIM_FLAGS += -c
vsim-run: vsim-all
	$(VSIM) -work $(VWORK) $(ALL_VSIM_FLAGS) \
	$(RTLSRC_VOPT_TB_TOP) -do 'source $(VSIM_SCRIPT); exit -f'

# run tb and drop into interactive shell
.PHONY: vsim-run-sh
vsim-run-sh: ALL_VSIM_FLAGS += -c
vsim-run-sh: vsim-all
	$(VSIM) -work $(VWORK) $(ALL_VSIM_FLAGS) \
	$(RTLSRC_VOPT_TB_TOP) -do $(VSIM_SCRIPT)

# run tb with simulator gui
.PHONY: vsim-run-gui
vsim-run-gui: ALL_VSIM_FLAGS += $(VSIM_GUI_FLAGS)
vsim-run-gui: vsim-all
	$(VSIM) -work $(VWORK) $(ALL_VSIM_FLAGS) \
	$(RTLSRC_VOPT_TB_TOP) -do $(VSIM_SCRIPT)

.PHONY: tb-clean
tb-clean:
	if [ -d $(VWORK) ]; then rm -r $(VWORK); fi
	rm -f transcript vsim.wlf vsim.dbg trace_core*.log \
	.build-rtl .opt-rtl .lib-rtl *.vcd objdump

# run tb and exit
.PHONY: vsim-run-fp
vsim-run-fp: ALL_VSIM_FLAGS += -c
vsim-run-fp: vsim-all-fp
	$(VSIM) -work $(VWORK) $(ALL_VSIM_FLAGS) -GFPU=1 \
	$(RTLSRC_VOPT_TB_TOP) -do 'source $(VSIM_SCRIPT); exit -f'

# run tb and drop into interactive shell
.PHONY: vsim-run-sh-fp
vsim-run-sh-fp: ALL_VSIM_FLAGS += -c
vsim-run-sh-fp: vsim-all-fp
	$(VSIM) -work $(VWORK) $(ALL_VSIM_FLAGS) \
	$(RTLSRC_VOPT_TB_TOP) -do $(VSIM_SCRIPT)

# run tb with simulator gui
.PHONY: vsim-run-gui-fp
vsim-run-gui-fp: ALL_VSIM_FLAGS += $(VSIM_GUI_FLAGS)
vsim-run-gui-fp: vsim-all-fp
	$(VSIM) -work $(VWORK) $(ALL_VSIM_FLAGS) -GFPU=1 \
	$(RTLSRC_VOPT_TB_TOP) -do $(VSIM_SCRIPT)

.PHONY: tb-clean-fp
tb-clean-fp:
	if [ -d $(VWORK) ]; then rm -r $(VWORK); fi
	rm -f transcript vsim.wlf vsim.dbg trace_core*.log \
	.build-rtl-fp .opt-rtl-fp .lib-rtl-fp *.vcd objdump

# rules to generate hex (loadable by simulators) from elf
%.hex: %.elf
	$(RISCV_EXE_PREFIX)objcopy -O verilog $< $@

%.dis: %.elf
	$(RISCV_EXE_PREFIX)objdump -S $^


# Running custom programs:
# This is an example for running a Hello World in the testbench
# We link with our custom crt0.s and syscalls.c against newlib so that we can
# use the c standard library
custom/hello_world.elf: custom/hello_world.c
	$(RISCV_EXE_PREFIX)gcc -march=rv32imc -o $@ -w -Os -g -nostdlib \
		$(CUSTOM_GCC_FLAGS) \
		-T custom/link.ld \
		-static \
		custom/crt0.S \
		$^ mem_stall/mem_stall.c custom/syscalls.c custom/vectors.S \
		-I $(RISCV)/riscv32-unknown-elf/include \
		-I mem_stall \
		-L $(RISCV)/riscv32-unknown-elf/lib \
		-lc -lm -lgcc
custom-clean:
	rm -rf custom/hello_world.elf custom/hello_world.hex

.PHONY: custom-asim-run
custom-asim-run: asim-all custom/hello_world.hex
custom-asim-run: ALL_ASIM_FLAGS += "+firmware=custom/hello_world.hex"
custom-asim-run: asim-run

.PHONY: custom-asim-run-gui
custom-asim-run-gui: asim-all custom/hello_world.hex
custom-asim-run-gui: ALL_ASIM_FLAGS += "+firmware=custom/hello_world.hex"
custom-asim-run-gui: asim-run-gui

.PHONY: custom-vsim-run
custom-vsim-run: vsim-all custom/hello_world.hex
custom-vsim-run: ALL_VSIM_FLAGS += "+firmware=custom/hello_world.hex"
custom-vsim-run: vsim-run

.PHONY: custom-vsim-run-gui
custom-vsim-run-gui: vsim-all custom/hello_world.hex
custom-vsim-run-gui: ALL_VSIM_FLAGS += "+firmware=custom/hello_world.hex"
custom-vsim-run-gui: vsim-run-gui

# Running custom fp programs:
# This is an example for running a floating-point matrix multiplication in the testbench
# We link with our custom crt0.s and syscalls.c against newlib so that we can
# use the c standard library
custom_fp/main.elf: custom_fp/matmulNxN.c custom_fp/main.c
	$(RISCV_EXE_PREFIX)gcc -march=rv32imfc -mabi=ilp32f -o $@ -w -g -nostdlib \
		$(CUSTOM_GCC_FLAGS) \
		-T custom/link.ld  \
		-static \
		custom/crt0.S \
		$^ custom/syscalls.c custom/vectors.S \
		-I $(RISCV)/riscv32-unknown-elf/include \
		-L $(RISCV)/riscv32-unknown-elf/lib \
		-lc -lm -lgcc
custom-fp-clean:
	rm -rf custom_fp/main.elf custom_fp/main.hex

.PHONY: custom-fp-asim-run
custom-fp-asim-run: asim-all-fp custom_fp/main.hex
custom-fp-asim-run: ALL_ASIM_FLAGS += "+firmware=custom_fp/main.hex"
custom-fp-asim-run: asim-run-fp

.PHONY: custom-fp-asim-run-gui
custom-fp-asim-run-gui: asim-all-fp custom_fp/main.hex
custom-fp-asim-run-gui: ALL_ASIM_FLAGS += "+firmware=custom_fp/main.hex"
custom-fp-asim-run-gui: asim-run-gui-fp


.PHONY: custom-fp-vsim-run
custom-fp-vsim-run: vsim-all-fp custom_fp/main.hex
custom-fp-vsim-run: ALL_VSIM_FLAGS += "+firmware=custom_fp/main.hex"
custom-fp-vsim-run: vsim-run-fp


.PHONY: custom-fp-vsim-run-gui
custom-fp-vsim-run-gui: vsim-all-fp custom_fp/main.hex
custom-fp-vsim-run-gui: ALL_VSIM_FLAGS += "+firmware=custom_fp/main.hex"
custom-fp-vsim-run-gui: vsim-run-gui-fp

# compile and run interrupt
interrupt/interrupt.elf: interrupt/interrupt.c
	$(RISCV_EXE_PREFIX)gcc -march=rv32imc -o $@ -w -Os -g -nostdlib \
		${CUSTOM_GCC_FLAGS} \
		-T custom/link.ld  \
		-static \
		custom/crt0.S \
		$^ mem_stall/mem_stall.c custom/syscalls.c interrupt/vectors.S \
		-I $(RISCV)/riscv32-unknown-elf/include \
		-I mem_stall/ \
		-L $(RISCV)/riscv32-unknown-elf/lib \
		-lc -lm -lgcc
interrupt-clean:
	rm -rf interrupt/interrupt.elf interrupt/interrupt.hex

.PHONY: interrupt-asim-run
interrupt-asim-run: asim-all interrupt/interrupt.hex
interrupt-asim-run: ALL_ASIM_FLAGS += "+firmware=interrupt/interrupt.hex"
interrupt-asim-run: asim-run

.PHONY: interrupt-asim-run-gui
interrupt-asim-run-gui: asim-all interrupt_test/interrupt_test.hex
interrupt-asim-run-gui: ALL_ASIM_FLAGS += "+firmware=interrupt_test/interrupt_test.hex"
interrupt-asim-run-gui: asim-run-gui


.PHONY: interrupt-vsim-run
interrupt-vsim-run: vsim-all interrupt/interrupt.hex
interrupt-vsim-run: ALL_VSIM_FLAGS += "+firmware=interrupt/interrupt.hex"
interrupt-vsim-run: vsim-run

.PHONY: interrupt-vsim-run-gui

interrupt-vsim-run-gui: vsim-all interrupt/interrupt.hex
interrupt-vsim-run-gui: ALL_VSIM_FLAGS += "+firmware=interrupt/interrupt.hex"
interrupt-vsim-run-gui: vsim-run-gui

# Compile and run HW-loops test
# Until the compiler will correctly handle HW-loops, manually insert them (no jumps/branch in the body)
# Compile with "rv32imxpulpv2" with "-mnohwloop" or "-O0" to avoid the compiler inserting other hw-loops
# Do not use RVC, as the instructions should be aligned and not compressed
hwlp_test/hwlp_test.elf: hwlp_test/hwlp_test.c
	$(RISCV_EXE_PREFIX)gcc -march=rv32imxpulpv2 -mnohwloop -o $@ -w -O0 -g -nostdlib \
		$(CUSTOM_GCC_FLAGS) \
		-T custom/link.ld \
		-static \
		custom/crt0.S \
		$^ mem_stall/mem_stall.c custom/syscalls.c custom/vectors.S \
		-I $(RISCV)/riscv32-unknown-elf/include \
		-I mem_stall \
		-L $(RISCV)/riscv32-unknown-elf/lib \
		-lc -lm -lgcc
hwlp-clean:
	rm -rf hwlp_test/hwlp_test.elf hwlp_test/hwlp_test.hex

.PHONY: hwlp-asim-run
hwlp-asim-run: asim-all hwlp_test/hwlp_test.hex
hwlp-asim-run: ALL_ASIM_FLAGS +=  "+firmware=hwlp_test/hwlp_test.hex"
hwlp-asim-run: asim-run

.PHONY: hwlp-asim-run-gui
hwlp-asim-run-gui: asim-all hwlp_test/hwlp_test.hex
hwlp-asim-run-gui: ALL_ASIM_FLAGS +=  "+firmware=hwlp_test/hwlp_test.hex"
hwlp-asim-run-gui: asim-run-gui

.PHONY: hwlp-vsim-run
hwlp-vsim-run: vsim-all hwlp_test/hwlp_test.hex
hwlp-vsim-run: ALL_VSIM_FLAGS += "+firmware=hwlp_test/hwlp_test.hex"
hwlp-vsim-run: vsim-run

.PHONY: hwlp-vsim-run-gui
hwlp-vsim-run-gui: vsim-all hwlp_test/hwlp_test.hex
hwlp-vsim-run-gui: ALL_VSIM_FLAGS += "+firmware=hwlp_test/hwlp_test.hex"
hwlp-vsim-run-gui: vsim-run-gui

# general targets
.PHONY: clean
clean: tb-clean tb-clean-fp rvr-tb-clean rvr-tb-clean-fp custom-clean custom-fp-clean interrupt-clean hwlp-clean

